;; Analyzed by ClojureScript 1.7.228
{:use-macros nil, :excludes #{remove replace next}, :name clojure.zip, :imports nil, :requires nil, :uses nil, :defs {rightmost {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 142, :column 7, :end-line 142, :end-column 16, :arglists (quote ([loc])), :doc "Returns the loc of the rightmost sibling of the node at this loc, or self"}, :name clojure.zip/rightmost, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 16, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 142, :end-line 142, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns the loc of the rightmost sibling of the node at this loc, or self"}, insert-child {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 194, :column 7, :end-line 194, :end-column 19, :arglists (quote ([loc item])), :doc "Inserts the item as the leftmost child of the node at this loc,\n  without moving"}, :name clojure.zip/insert-child, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 19, :method-params ([loc item]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 194, :end-line 194, :max-fixed-arity 2, :fn-var true, :arglists (quote ([loc item])), :doc "Inserts the item as the leftmost child of the node at this loc,\n  without moving"}, left {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 150, :column 7, :end-line 150, :end-column 11, :arglists (quote ([loc])), :doc "Returns the loc of the left sibling of the node at this loc, or nil"}, :name clojure.zip/left, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 11, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 150, :end-line 150, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns the loc of the left sibling of the node at this loc, or nil"}, path {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 82, :column 7, :end-line 82, :end-column 11, :arglists (quote ([loc])), :doc "Returns a seq of nodes leading to this loc"}, :name clojure.zip/path, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 11, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 82, :end-line 82, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns a seq of nodes leading to this loc"}, leftmost {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 157, :column 7, :end-line 157, :end-column 15, :arglists (quote ([loc])), :doc "Returns the loc of the leftmost sibling of the node at this loc, or self"}, :name clojure.zip/leftmost, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 15, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 157, :end-line 157, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns the loc of the leftmost sibling of the node at this loc, or self"}, append-child {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 200, :column 7, :end-line 200, :end-column 19, :arglists (quote ([loc item])), :doc "Inserts the item as the rightmost child of the node at this loc,\n  without moving"}, :name clojure.zip/append-child, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 19, :method-params ([loc item]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 200, :end-line 200, :max-fixed-arity 2, :fn-var true, :arglists (quote ([loc item])), :doc "Inserts the item as the rightmost child of the node at this loc,\n  without moving"}, branch? {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 64, :column 7, :end-line 64, :end-column 14, :arglists (quote ([loc])), :doc "Returns true if the node at loc is a branch"}, :name clojure.zip/branch?, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 14, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 64, :end-line 64, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns true if the node at loc is a branch"}, children {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 69, :column 7, :end-line 69, :end-column 15, :arglists (quote ([loc])), :doc "Returns a seq of the children of node at loc, which must be a branch"}, :name clojure.zip/children, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 15, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 69, :end-line 69, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns a seq of the children of node at loc, which must be a branch"}, remove {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 237, :column 7, :end-line 237, :end-column 13, :arglists (quote ([loc])), :doc "Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."}, :name clojure.zip/remove, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 13, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 237, :end-line 237, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk."}, down {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 98, :column 7, :end-line 98, :end-column 11, :arglists (quote ([loc])), :doc "Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"}, :name clojure.zip/down, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 11, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 98, :end-line 98, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children"}, replace {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 183, :column 7, :end-line 183, :end-column 14, :arglists (quote ([loc node])), :doc "Replaces the node at this loc, without moving"}, :name clojure.zip/replace, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 14, :method-params ([loc node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 183, :end-line 183, :max-fixed-arity 2, :fn-var true, :arglists (quote ([loc node])), :doc "Replaces the node at this loc, without moving"}, zipper {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 18, :column 7, :end-line 18, :end-column 13, :arglists (quote ([branch? children make-node root])), :doc "Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."}, :name clojure.zip/zipper, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 13, :method-params ([branch? children make-node root]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 18, :end-line 18, :max-fixed-arity 4, :fn-var true, :arglists (quote ([branch? children make-node root])), :doc "Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node."}, end? {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 232, :column 7, :end-line 232, :end-column 11, :arglists (quote ([loc])), :doc "Returns true if loc represents the end of a depth-first walk"}, :name clojure.zip/end?, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 11, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 232, :end-line 232, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns true if loc represents the end of a depth-first walk"}, edit {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 189, :column 7, :end-line 189, :end-column 11, :arglists (quote ([loc f & args])), :doc "Replaces the node at this loc with the value of (f node args)", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(loc f args)], :arglists ([loc f & args]), :arglists-meta (nil)}}, :name clojure.zip/edit, :variadic true, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(loc f args)], :arglists ([loc f & args]), :arglists-meta (nil)}, :method-params [(loc f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 189, :end-line 189, :max-fixed-arity 2, :fn-var true, :arglists ([loc f & args]), :doc "Replaces the node at this loc with the value of (f node args)"}, make-node {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 76, :column 7, :end-line 76, :end-column 16, :arglists (quote ([loc node children])), :doc "Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."}, :name clojure.zip/make-node, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 16, :method-params ([loc node children]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 76, :end-line 76, :max-fixed-arity 3, :fn-var true, :arglists (quote ([loc node children])), :doc "Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor."}, vector-zip {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 42, :column 7, :end-line 42, :end-column 17, :arglists (quote ([root])), :doc "Returns a zipper for nested vectors, given a root vector"}, :name clojure.zip/vector-zip, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 17, :method-params ([root]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 42, :end-line 42, :max-fixed-arity 1, :fn-var true, :arglists (quote ([root])), :doc "Returns a zipper for nested vectors, given a root vector"}, node {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 60, :column 7, :end-line 60, :end-column 11, :arglists (quote ([loc])), :doc "Returns the node at loc"}, :name clojure.zip/node, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 11, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 60, :end-line 60, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns the node at loc"}, up {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 111, :column 7, :end-line 111, :end-column 9, :arglists (quote ([loc])), :doc "Returns the loc of the parent of the node at this loc, or nil if at\n  the top"}, :name clojure.zip/up, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 9, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 111, :end-line 111, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns the loc of the parent of the node at this loc, or nil if at\n  the top"}, insert-right {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 174, :column 7, :end-line 174, :end-column 19, :arglists (quote ([loc item])), :doc "Inserts the item as the right sibling of the node at this loc,\n  without moving"}, :name clojure.zip/insert-right, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 19, :method-params ([loc item]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 174, :end-line 174, :max-fixed-arity 2, :fn-var true, :arglists (quote ([loc item])), :doc "Inserts the item as the right sibling of the node at this loc,\n  without moving"}, rights {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 92, :column 7, :end-line 92, :end-column 13, :arglists (quote ([loc])), :doc "Returns a seq of the right siblings of this loc"}, :name clojure.zip/rights, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 13, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 92, :end-line 92, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns a seq of the right siblings of this loc"}, root {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 124, :column 7, :end-line 124, :end-column 11, :arglists (quote ([loc])), :doc "zips all the way up and returns the root node, reflecting any\n changes."}, :name clojure.zip/root, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 11, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 124, :end-line 124, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "zips all the way up and returns the root node, reflecting any\n changes."}, next {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 206, :column 7, :end-line 206, :end-column 11, :arglists (quote ([loc])), :doc "Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."}, :name clojure.zip/next, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 11, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 206, :end-line 206, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there."}, seq-zip {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 34, :column 7, :end-line 34, :end-column 14, :arglists (quote ([root])), :doc "Returns a zipper for nested sequences, given a root sequence"}, :name clojure.zip/seq-zip, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 14, :method-params ([root]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 34, :end-line 34, :max-fixed-arity 1, :fn-var true, :arglists (quote ([root])), :doc "Returns a zipper for nested sequences, given a root sequence"}, insert-left {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 165, :column 7, :end-line 165, :end-column 18, :arglists (quote ([loc item])), :doc "Inserts the item as the left sibling of the node at this loc,\n without moving"}, :name clojure.zip/insert-left, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 18, :method-params ([loc item]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 165, :end-line 165, :max-fixed-arity 2, :fn-var true, :arglists (quote ([loc item])), :doc "Inserts the item as the left sibling of the node at this loc,\n without moving"}, prev {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 221, :column 7, :end-line 221, :end-column 11, :arglists (quote ([loc])), :doc "Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."}, :name clojure.zip/prev, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 11, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 221, :end-line 221, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil."}, right {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 135, :column 7, :end-line 135, :end-column 12, :arglists (quote ([loc])), :doc "Returns the loc of the right sibling of the node at this loc, or nil"}, :name clojure.zip/right, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 12, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 135, :end-line 135, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns the loc of the right sibling of the node at this loc, or nil"}, lefts {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 87, :column 7, :end-line 87, :end-column 12, :arglists (quote ([loc])), :doc "Returns a seq of the left siblings of this loc"}, :name clojure.zip/lefts, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 12, :method-params ([loc]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 87, :end-line 87, :max-fixed-arity 1, :fn-var true, :arglists (quote ([loc])), :doc "Returns a seq of the left siblings of this loc"}, xml-zip {:protocol-inline nil, :meta {:file "/home/rafik/work/scheje/.cljs_node_repl/clojure/zip.cljs", :line 50, :column 7, :end-line 50, :end-column 14, :arglists (quote ([root])), :doc "Returns a zipper for xml elements (as from xml/parse),\n  given a root element"}, :name clojure.zip/xml-zip, :variadic false, :file ".cljs_node_repl/clojure/zip.cljs", :end-column 14, :method-params ([root]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 50, :end-line 50, :max-fixed-arity 1, :fn-var true, :arglists (quote ([root])), :doc "Returns a zipper for xml elements (as from xml/parse),\n  given a root element"}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:ppath :zip/branch? :r :zip/children :content :l :zip/make-node :pnodes :changed? :end}, :order [:zip/branch? :zip/children :zip/make-node :content :pnodes :l :r :ppath :changed? :end]}, :doc "Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet"}